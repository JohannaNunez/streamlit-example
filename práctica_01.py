# -*- coding: utf-8 -*-
"""Práctica_01.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zDZh_ZeqS_sHfKwB6ywyF6kUaYmeV3Rt

## **Series de tiempo**

Para esta práctica trabajaremos con un dataset de temperaturas de la Ciudad Autónoma de Buenos Aires.

Es fundamental que, como data scientist, conozcamos en detalle las funcionalidades y características que nos brinda el módulo `datetime` provisto por Python. En esta línea, aconsejamos revisar y tener como fuente de consulta el siguiente [link](https://realpython.com/python-datetime/).

También, familiarizarnos con ella, nos hará más amena la tarea de trabajar con fechas en series de tiempo.

En esta primera práctica ahondaremos en cómo realizar un EDA en series de tiempo e indenfificar sus componentes.

En una segunda práctica haremos forecasting con `ARIMA`, dentro de los modelos clásicos estocásticos.

### 1. EDA
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import datetime
sns.set()

data = pd.read_csv('..\Datasets\Clase_04_temperatura.csv')

data

data.anio.max() - data.anio.min() # o data["anio"].max()

"""Tenemos una `frecuencia de muestreo` diaria y una `ventana temporal` con un tamaño de 59 años

Tenemos la información suficiente como para crear el campo `fecha`. Veamos cómo hacerlo:
"""

{'year':data.anio, 'month': data.mes, 'day': data.dia}

data['fecha'] = pd.to_datetime({'year':data.anio, 'month': data.mes, 'day': data.dia})

data.head(3)

"""Ya no necesitamos las columnas que utilizamos para crear el campo fecha."""

data.drop(columns= ['dia','mes', 'anio'], inplace = True)

"""Es momento de visualizar nuestra serie de tiempo."""

plt.figure(figsize = (15,5))

plt.plot(data.fecha, data.Tmax, label = 'Temperatura máxima')
plt.plot(data.fecha, data.Tmin, label = 'Temperatura mínima')
plt.legend()
plt.xlabel('Fecha')
plt.ylabel('Temperatura (°C)')
#plt.ylim(-10,40)
plt.show()

"""Tenemos algunos outliers que nos amplían en demasía el valor máximo del eje Y. Probemos limitar el eje Y."""

plt.figure(figsize = (15,5))

plt.plot(data.fecha, data.Tmax, label = 'Temperatura máxima')
plt.plot(data.fecha, data.Tmin, label = 'Temperatura mínima')
plt.legend()
plt.xlabel('Fecha')
plt.ylabel('Temperatura (°C)')
plt.ylim(-20,50)
plt.show()

"""Como recordarán de lo visto en la clase teórica, cuando tenemos una frecuencia de muestreo relativamente chica en una ventana temporal grande corremos el riesgo de que, al querer graficarla, obtengamos una serie muy distorsionada o saturada. Para ello, recurríamos al `resampleo`.

Probemos reaugrupar o resumir nuestros datos en una frecuencia de muestreo más grande -semanal o mensual-.
"""

# Agrupamos nuestras mediciones por el promedio semanal

semanal = data.resample('W', on = 'fecha').mean()
semanal.head()

plt.figure(figsize = (15,5))

plt.plot(semanal.index, semanal.Tmax, label = 'Temperatura máxima')
plt.plot(semanal.index, semanal.Tmin, label = 'Temperatura mínima')
plt.xlabel('Fecha')
plt.ylabel('Temperatura (°C)')
#plt.ylim(-10,40)
plt.legend()
plt.show()

"""Mejoró un poco, ¿verdad?

Comenten la línea `plt.ylim(-10,40)` y noten un detalle respecto a la primera visualuzación que hicimos. Ahora, nuestro pico del outlier más alto ya no está en torno a los 500º sino cercano a los 80º ¿Por qué creés que sucedió esto?
"""

# Ahora veamos qué pasa si reagrupamos las temperaturas mensualmente.

mensual = data.resample('M', on = 'fecha').mean()
mensual.head()

plt.figure(figsize = (15,5))

plt.plot(mensual.index, mensual.Tmax, label = 'Temperatura máxima')
plt.plot(mensual.index, mensual.Tmin, label = 'Temperatura mínima')
plt.xlabel('Fecha')
plt.ylabel('Temperatura (°C)')
#plt.xlim(datetime.date(1990,1,1), datetime.date(2018,1,1))

plt.legend()
plt.show()

"""En este caso, ya no es necesario limitar el eje Y por la miniaturización del gráfico que provocaba nuestro punto máximo.

Práctiquemos un caso de uso la librería `datetime` para limitar el periodo temporal que queremos abarcar de nuestra serie.
"""

plt.figure(figsize = (15,5))

plt.plot(mensual.index, mensual.Tmax, label = 'Temperatura máxima')
plt.plot(mensual.index, mensual.Tmin, label = 'Temperatura mínima')
plt.xlabel('Fecha')
plt.ylabel('Temperatura (°C)')
plt.xlim(datetime.date(2000,1,1), datetime.date(2015,1,1))

plt.legend()
plt.show()

"""### **`Componentes de la serie de tiempo`**

Veremos dos formas de obtenerlas: *media móvil* y *regresión lineal*.

***Media móvil***

Aquí utilizaremos la función *rolling window*. Fijaremos una ventana que define la cantidad de registros anteriores + actual para realizar el promedio en la fila actual.

Vamos a sacar algunos valores de medición y, a su vez, rellenar los faltantes.
"""

semanal.Tmin[semanal.Tmin > 50] = np.nan

# Observamos cuántos faltantes tenemos

print(semanal.isnull().sum())

# Imputamos faltantes con la función interpolate

semanal = semanal.interpolate()

"""Ahora vamos a obtener la temperatura promedio semanal -combinando las temperaturas mínimas y máximas-."""

semanal['Tmean'] = (semanal.Tmax + semanal.Tmin)/2

semanal.head(3)

"""Pasemos a establecer el tamaño nuestra ventana móvil:"""

# Probar ir variando este valor donde elegimos la cantidad de semanas con la que se irá calculando la media

ventana = (105)

semanal_promedio_tendencia = semanal.Tmean.rolling(window=ventana, center = True).mean()
semanal_promedio_tendencia.head(200)

"""*Cuanto más grande sea nuestra ventana, más valores necesitará para empezar a establecer valores y, por ende, más faltantes observemos en el dataframe*."""

plt.figure(figsize = (15,5))
plt.plot(semanal.index, semanal.Tmean, label = 'Temperatura Promedio')
plt.plot(semanal_promedio_tendencia, lw = 4, label = 'Temperatura Promedio - Rolling Window')
plt.xlabel('Fecha')
plt.ylabel('Temperatura (°C)')
plt.legend()
plt.show()

"""***Tendencia lineal***

Aquí ajustaremos una regresión lineal a la serie. Tomar en consideración que la aplicabilidad de este método es muy limitada a casos muy puntuales.

Como primer paso, no podemos utilizar una regresión lineal con el tipo de fechas que tenemos, por lo que habrá que pasarlas a un formato numérico.
"""

semanal['fecha_numeros']=semanal.index.map(datetime.datetime.toordinal)

semanal.head()

from sklearn.linear_model import LinearRegression

reg_lineal = LinearRegression() #Instanciamos el modelo

reg_lineal.fit(semanal.fecha_numeros.values.reshape(-1, 1), semanal.Tmean) # Lo entrenamos

plt.figure(figsize = (15,5))

plt.plot(semanal.index, semanal.Tmean, label = 'Temperatura Promedio')
plt.plot(semanal_promedio_tendencia, ls = '--', lw = 4, label = 'Temperatura Promedio - Rolling Window')
plt.plot(semanal.index, reg_lineal.predict(semanal.fecha_numeros.values.reshape(-1, 1)), lw = 4, label = 'Temperatura Promedio - Ajuste Lineal')

plt.xlabel('Fecha')
plt.ylabel('Temperatura (°C)')
plt.legend()
plt.show()

# Veamos las componentes

plt.figure(figsize = (12,9))

plt.subplot(3,1,1)
plt.title('Serie Original')
plt.plot(semanal.index, semanal.Tmean)
plt.ylabel('Temperatura (°C)')

plt.subplot(3,1,2)
plt.title('Tendencia Rolling Window')
plt.plot(semanal_promedio_tendencia)
plt.ylabel('Temperatura (°C)')

plt.subplot(3,1,3)
plt.title('Diferencia entre la serie original y la tendencia')
plt.plot(semanal.index, semanal.Tmean - semanal_promedio_tendencia)
plt.xlabel('Fecha')
plt.ylabel('Temperatura (°C)')

plt.tight_layout()
plt.show()

"""***Estacionalidad***

En este caso, agrupamos los datos por mes y mostramos las distribuciones de cada grupo. De esta manera, se visualiza la estacionalidad anual. Podría buscarse, también, una estacionalidad mensual y agrupar los datos por día. Todo eso depende de los datos con los que estemos trabajando. Aquí, como estamos trabajando con temperaturas, al observar una estacionalidad anual podemos corroborar el patrón y la incidenciade las 4 estaciones del año en la temperatura promedio.
"""

# Agrupamos los datos por mes y mostramos las distribuciones de cada grupo. De esta manera, se visualiza la estacionalidad anual.

plt.figure(figsize = (20,9))
sns.boxplot(data=semanal,x=semanal.index.month,y= semanal.Tmean)
plt.title('Estacionalidad anual de la temperatura en CABA', fontsize = 15)
plt.xlabel('Mes')
plt.ylabel('Temperatura')

"""Existen dos librerías muy importantes que nos permiten obtener las componentes de una serie de tiempo de manera más sencilla.

Una es `stats model` y la otra `Prophet`.

Recomendamos ir familiarizándose con la primera de ellas.

***Stats model***
"""

#import sys
#!{sys.executable} -m pip install statsmodels

from statsmodels.tsa.seasonal import seasonal_decompose

result = seasonal_decompose(semanal.Tmean, model='additive') # y= t+s+u podría ser y=t*s*u

import matplotlib
matplotlib.rcParams['figure.figsize'] = [15,10]
result.plot()
plt.title('Componentes de la serie de tiempo')
plt.show()

#Exportamos el csv ya transformado
#semanal.drop(columns = 'fecha_numeros', inplace = True)
#semanal.to_csv('Clase_04_temperatura_transf.csv')